{
	"Debug": false,
	"EnableSyslog": false,
	"ListenAddress": ":30001",

	"MySQLTopologyUser": "orch_client",
	"MySQLTopologyPassword": "7yZ3WjZThF5eKqh5",
	"MySQLTopologyCredentialsConfigFile": "",
	"MySQLTopologySSLPrivateKeyFile": "",
	"MySQLTopologySSLCertFile": "",
	"MySQLTopologySSLCAFile": "",
	"MySQLTopologySSLSkipVerify": true,
	"MySQLTopologyUseMutualTLS": false,
	"MySQLTopologyUseMixedTLS": false,
	"MySQLTopologyMaxPoolConnections": 3,

	"MySQLOrchestratorHost": "127.0.0.1",
	"MySQLOrchestratorPort": 3306,
	"MySQLOrchestratorDatabase": "orchestrator",
	"MySQLOrchestratorUser": "orchestrator_srv",
	"MySQLOrchestratorPassword": "orc_server_password",
	"MySQLOrchestratorCredentialsConfigFile": "",
	"MySQLOrchestratorSSLPrivateKeyFile": "",
	"MySQLOrchestratorSSLCertFile": "",
	"MySQLOrchestratorSSLCAFile": "",
	"MySQLOrchestratorSSLSkipVerify": true,
	"MySQLOrchestratorUseMutualTLS": false,
	"BackendDB": "mysql",

	"MySQLConnectTimeoutSeconds": 1,
	"DefaultInstancePort": 3306,
	"ReplicationLagQuery": "",
	"SlaveStartPostWaitMilliseconds": 1000,
	"DiscoverByShowSlaveHosts": false,
	"InstancePollSeconds": 5,

	"ReadLongRunningQueries": false,
	"SkipMaxScaleCheck": true,
	"BinlogFileHistoryDays": 10,
	"UnseenInstanceForgetHours": 240,
	"SnapshotTopologiesIntervalHours": 0,
	"InstanceBulkOperationsWaitTimeoutSeconds": 10,
	"ActiveNodeExpireSeconds": 5,
	"HostnameResolveMethod": "default",
	"MySQLHostnameResolveMethod": "@@hostname",
	"SkipBinlogServerUnresolveCheck": true,
	"ExpiryHostnameResolvesMinutes": 60,
	"RejectHostnameResolvePattern": "",
	"ReasonableReplicationLagSeconds": 60,
	"ProblemIgnoreHostnameFilters": [],
	"VerifyReplicationFilters": false,
	"MaintenanceOwner": "orchestrator",
	"ReasonableMaintenanceReplicationLagSeconds": 20,
	"MaintenanceExpireMinutes": 10,
	"MaintenancePurgeDays": 365,
	"CandidateInstanceExpireMinutes": 60,
	"AuditLogFile": "",
	"AuditToSyslog": false,
	"AuditPageSize": 20,
	"AuditPurgeDays": 365,
	"RemoveTextFromHostnameDisplay": "",
	"ReadOnly": false,
	"AuthenticationMethod": "",
	"HTTPAuthUser": "",
	"HTTPAuthPassword": "",
	"AuthUserHeader": "",
	"PowerAuthUsers": [
		"*"
	],
	"ClusterNameToAlias": {
		"127.0.0.1": "test suite"
	},
	"AccessTokenUseExpirySeconds": 60,
	"AccessTokenExpiryMinutes": 1440,
	"DetectClusterAliasQuery": "select ifnull(max(cluster_name), '') as cluster_alias from meta.cluster where anchor=1",
	"DetectClusterDomainQuery": "",
	"DataCenterPattern": "",
	"DetectDataCenterQuery": "SELECT left(@@hostname,2)",
	"PhysicalEnvironmentPattern": "",
	"PromotionIgnoreHostnameFilters": [

	],
	"ServeAgentsHttp": false,
	"UseSSL": false,
	"UseMutualTLS": false,
	"SSLSkipVerify": false,
	"SSLPrivateKeyFile": "",
	"SSLCertFile": "",
	"SSLCAFile": "",
	"SSLValidOUs": [

	],
	"StatusEndpoint": "/api/status",
	"StatusSimpleHealth": true,
	"StatusOUVerify": false,
	"HttpTimeoutSeconds": 60,
	"StaleSeedFailMinutes": 60,
	"SeedAcceptableBytesDiff": 8192,
	"SeedWaitSecondsBeforeSend": 2,
	"PseudoGTIDPattern": "drop view if exists `meta`.`_pseudo_gtid_hint__asc:",
	"PseudoGTIDPatternIsFixedSubstring": true,
	"PseudoGTIDMonotonicHint": "asc:",
	"DetectPseudoGTIDQuery": "select count(*) as pseudo_gtid_exists from meta.pseudo_gtid_status where anchor = 1 and time_generated > now() - interval 1 day",
	"BinlogEventsChunkSize": 10000,
	"BufferBinlogEvents": true,
	"SkipBinlogEventsContaining": [
		"@@SESSION.GTID_NEXT= 'ANONYMOUS'"
	],
	"ReduceReplicationAnalysisCount": false,
	"FailureDetectionPeriodBlockMinutes": 60,
	"RecoveryPeriodBlockSeconds": 600,
	"RecoveryIgnoreHostnameFilters": [

	],
	"RecoverMasterClusterFilters": [
		"*"
	],
	"RecoverIntermediateMasterClusterFilters": [
		"*"
	],
	"OnFailureDetectionProcesses": [
	// todo bug 需要对 {failureType} 做判断 再决定是否切换 下面的步骤全面改成shell脚本
		"echo '2 $(date '+%Y-%m-%d %H:%M:%S') 检测故障时执行 Detected {failureType} on {failureCluster}. Affected replicas: {countSlaves}' >> /tmp/recovery.log",
		"/usr/local/orchestrator/bin/webhook/orch_webhook SendAlerts --alerts_api_addr http://10.166.206.81:21000/api/v1/orch_change_ha  --alerts_info 'Detected {failureType} on {failureCluster}. Affected replicas: {countSlaves}' ",
		"/usr/local/orchestrator/bin/webhook/orch_webhook Op_set_read_only -r {failureCluster} -m /usr/local/orchestrator/bin/webhook/server.crt -l example.server.com --WorkNode 31081 -b && echo 'set read_only on {failureCluster} success'||echo 'set read_only on {failureCluster} failed' ",
		"/usr/local/orchestrator/bin/webhook/orch_webhook Modify_roles -i {failureCluster} -a 10.166.201.75:3306 -p letsg0 -u root -r standby "
	],
	"PreGracefulTakeoverProcesses": [
		"echo '1 [只对Graceful] 在主变为只读之前立即执行（mysql master故障的时候，不会触发该Process） Planned takeover about to take place on {failureCluster}. Master will switch to read_only' >> /tmp/recovery.log",
		"/usr/local/orchestrator/bin/webhook/orch_webhook SendAlerts --alerts_api_addr http://10.166.206.81:21000/api/v1/orch_change_ha  --alerts_info 'Planned takeover about to take place on {failureCluster}. Master will switch to read_only' ",
		"echo 'todo 输入合适的{占位符} {failureType}, {instanceType}, {isMaster}, {isCoMaster}, {failureDescription}, {command}, {failedHost}, {failureCluster}, {failureClusterAlias}, {failureClusterDomain}, {failedPort}, {successorHost}, {successorPort}, {countReplicas}, {replicaHosts}, {isDowntimed} 在要下线的主节点执行set read_only'"
	],
	"PreFailoverProcesses": [
		// todo bug 需要对 {failureType} 做判断 再决定是否切换 下面的步骤全面改成shell脚本
		"echo '3 $(date '+%Y-%m-%d %H:%M:%S') 在执行恢复操作之前立即执行 Will recover from {failureType} on {failureCluster}' >> /tmp/recovery.log",
		"echo '调用webhook Op_dead_master, 完成对旧主(可达的场景下)set read_only并且完成vip下线'>>/tmp/recovery.log",
		"/usr/local/orchestrator/bin/webhook/orch_webhook SendAlerts --alerts_api_addr http://10.166.206.81:21000/api/v1/orch_change_ha  --alerts_info 'Planned takeover about to take place on {failureCluster}. Master will switch to read_only'",
		"echo 'Processes to execute before doing a failover (aborting operation should any once of them exits with non-zero code; order of execution undefined). May and should use some of these placeholders: {failureType}, {instanceType}, {isMaster}, {isCoMaster}, {failureDescription}, {command}, {failedHost}, {failureCluster}, {failureClusterAlias}, {failureClusterDomain}, {failedPort}, {countReplicas}, {replicaHosts}, {isDowntimed}, run command: /usr/local/orchestrator/bin/webhook/orch_webhook Op_dead_master --Op_dead_master {failureCluster} -m /usr/local/orchestrator/bin/webhook/server.crt -l example.server.com --WorkNode 31081 '>> /tmp/recovery.log ",
		"/usr/local/orchestrator/bin/webhook/orch_webhook Op_dead_master --Op_dead_master {failureCluster} -m /usr/local/orchestrator/bin/webhook/server.crt -l example.server.com --WorkNode 31081  && echo 'push dingdinghooks success' || echo 'push dingdinghooks failed' "
	],
	"PostFailoverProcesses": [
		"echo '5 [成功] 在任何成功恢复结束时执行 (for all types) Recovered from {failureType} on {failureCluster}. Failed: {failedHost}:{failedPort}; Successor: {successorHost}:{successorPort}' >> /tmp/recovery.log",
		"/usr/local/orchestrator/bin/webhook/orch_webhook SendAlerts --alerts_api_addr http://10.166.206.81:21000/api/v1/orch_change_ha  --alerts_info 'Recovered from {failureType} on {failureCluster}. Failed: {failedHost}:{failedPort}; Successor: {successorHost}:{successorPort}'"
	],
	"PostUnsuccessfulFailoverProcesses": [
		"echo '8 [失败] 在任何不成功的恢复结束时执行 ' >> /tmp/recovery.log "
	],
	"PostMasterFailoverProcesses": [
	 	// todo bug 需要对 {failureType} 做判断 再决定是否切换 下面的步骤全面改成shell脚本
		"echo '4在主恢复成功结束时执行 Recovered from {failureType} on {failureCluster}. Failed: {failedHost}:{failedPort}; Promoted: {successorHost}:{successorPort}' >> /tmp/recovery.log",
		"echo 'will run command: /usr/local/orchestrator/bin/webhook/orch_webhook Op_new_master --Op_new_master {successorHost}:{successorPort} -m /usr/local/orchestrator/bin/webhook/server.crt -l example.server.com --WorkNode 31081'>>/tmp/recovery.log",
		"/usr/local/orchestrator/bin/webhook/orch_webhook SendAlerts --alerts_api_addr http://10.166.206.81:21000/api/v1/orch_change_ha  --alerts_info 'Recovered from {failureType} on {failureCluster}. Failed: {failedHost}:{failedPort}; Promoted: {successorHost}:{successorPort}'",
		"/usr/local/orchestrator/bin/webhook/orch_webhook Op_new_master --Op_new_master {successorHost}:{successorPort} -m /usr/local/orchestrator/bin/webhook/server.crt  -l example.server.com --WorkNode 31081 && echo 'push dingdinghooks success' || echo 'push dingdinghooks failed' ",
		"/usr/local/orchestrator/bin/webhook/orch_webhook Op_set_read_only -r {successorHost}:{successorPort} -m /usr/local/orchestrator/bin/webhook/server.crt -l example.server.com --WorkNode 31081 && echo 'set read_only off {failureCluster} success'||echo 'set read_only off {failureCluster} failed' ",
        "/usr/local/orchestrator/bin/webhook/orch_webhook Modify_roles -i {successorHost}:{successorPort} -a 10.166.201.75:3306 -p letsg0 -u root -r master "

	],
	"PostIntermediateMasterFailoverProcesses": [
	    "echo DeadIntermediateMaster: An intermediate master (replica with replicas) cannot be reached; All of its replicas are failing replication. This makes for a potential recovery process.",
		"echo ' DeadIntermediateMaster: 带有replicas节点的replica，Master-Slave1-Slave2，所以叫中间的主节点。Slave1 g的时候怎么操作，' ",
		"echo '6 在成功的中间主恢复结束时执行Recovered from {failureType} on {failureCluster}. Failed: {failedHost}:{failedPort}; Successor: {successorHost}:{successorPort}' >> /tmp/recovery.log"
	],
	"PostGracefulTakeoverProcesses": [
		"echo '7 [只对Graceful] 在旧主位于新晋升的主之后执行 Planned takeover complete' >> /tmp/recovery.log"
	],
	"CoMasterRecoveryMustPromoteOtherCoMaster": true,
	"DetachLostSlavesAfterMasterFailover": true,

	"ApplyMySQLPromotionAfterMasterFailover": true,
	"PreventCrossDataCenterMasterFailover": false,

	"PreventCrossRegionMasterFailover": false,
	"FailMasterPromotionOnLagMinutes": 0,

	"MasterFailoverLostInstancesDowntimeMinutes": 0,
	"PostponeReplicaRecoveryOnLagMinutes": 1,
	"OSCIgnoreHostnameFilters": [],
	"GraphitePollSeconds": 60,
	"GraphiteAddr": "",
	"GraphitePath": "",
	"GraphiteConvertHostnameDotsToUnderscores": true,
	"MySQLTopologyReadTimeoutSeconds": 3,
	"MySQLDiscoveryReadTimeoutSeconds": 3,

	"RaftEnabled": true,
	"RaftBind": "orch0",
	"RaftDataDir": "/var/lib/orchestrator",
	"DefaultRaftPort": 10008,
	"ConsulAddress": "redacted:8500",
	"RaftNodes": [
		"orch0",
		"orch1",
		"orch2"
	],

	"WebMessage": "生产环境的orchestrator工具 Web Ui, Node: orch0",
	"DelayMasterPromotionIfSQLThreadNotUpToDate": true,
	"FailMasterPromotionIfSQLThreadNotUpToDate": false

}